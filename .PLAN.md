# Braintrust Ruby SDK - Architecture & Design

## Overview

Ruby SDK for Braintrust based on OpenTelemetry, modeled after the braintrust-x-go implementation. Provides:
- OpenTelemetry-based tracing with automatic Braintrust integration
- OpenAI client instrumentation via Faraday middleware
- Evaluation framework for AI model testing

## Core Design: State Management

Hybrid approach inspired by Python libraries - supports both global state and explicit state passing.

### API Pattern

```ruby
# Simple case - sets global state (default)
Braintrust.init(
  api_key: ENV['BRAINTRUST_API_KEY'],
  project: "my-project"
)

# Explicit state (for testing, multi-tenant)
state = Braintrust.init(
  api_key: "key",
  project: "project",
  set_global: false
)

# All APIs accept optional state, fall back to global
Braintrust::Trace.enable(state)  # explicit
Braintrust::Trace.enable         # uses global

api = Braintrust::API.new(state)  # explicit
api = Braintrust::API.new         # uses global
```

### State Object

Holds configuration and initialized resources:
- `api_key` - Braintrust API key
- `org_name` - Organization name
- `project_id` - Default project ID
- `project_name` - Default project name
- `app_url` - Braintrust app URL
- `tracer_provider` - OpenTelemetry tracer provider instance

## Module Architecture

### Braintrust (Main Module)

**lib/braintrust.rb**

Entry point for the SDK. Manages global state.

```ruby
Braintrust.init(options)          # Initialize and optionally set global
Braintrust.current_state          # Get global state
Braintrust.with_state(state)      # Temporarily override state
```

### Braintrust::State

**lib/braintrust/state.rb**

Immutable state container.

- Thread-safe global state management
- Merges ENV vars with explicit options
- Validates required fields
- Holds tracer_provider instance

### Braintrust::Config

**lib/braintrust/config.rb**

Configuration and ENV var handling.

ENV vars:
- `BRAINTRUST_API_KEY` - API key
- `BRAINTRUST_ORG_NAME` - Organization name
- `BRAINTRUST_DEFAULT_PROJECT_ID` - Default project ID
- `BRAINTRUST_DEFAULT_PROJECT_NAME` - Default project name
- `BRAINTRUST_APP_URL` - App URL (default: https://www.braintrust.dev)
- `BRAINTRUST_API_URL` - API URL (default: https://api.braintrust.dev)

### Braintrust::Trace

**lib/braintrust/trace.rb**

OpenTelemetry integration.

```ruby
teardown = Braintrust::Trace.enable(state = nil)
# ... your code with tracing
teardown.call
```

Creates:
- OTLP HTTP exporter to Braintrust
- Custom span processor for Braintrust attributes
- Registers with OpenTelemetry

### Braintrust::Trace::SpanProcessor

**lib/braintrust/trace/span_processor.rb**

Custom OpenTelemetry span processor.

Features:
- Adds `braintrust.parent` attribute (project_name:X, experiment_id:X, etc.)
- Adds `braintrust.org` and `braintrust.app_url` attributes
- Resolves parent from context if set via `Braintrust::Trace.set_parent(context, parent)`
- Filters spans (optionally keep only AI spans)

### Braintrust::Trace::OpenAI

**lib/braintrust/trace/openai.rb**

Faraday middleware for OpenAI client instrumentation.

```ruby
client = OpenAI::Client.new(
  access_token: ENV['OPENAI_API_KEY'],
  faraday_middleware: Braintrust::Trace::OpenAI.middleware(state)
)
```

Features:
- Automatic span creation for chat.completions
- Records request/response as span attributes
- Parses and records token usage metrics
- Maps to gen_ai.* semantic conventions
- Handles streaming responses

### Braintrust::Eval

**lib/braintrust/eval.rb**

Evaluation framework.

```ruby
result = Braintrust::Eval.run(
  state: state,        # optional
  experiment: "name",
  cases: [...],
  task: ->(input) { ... },
  scorers: [...],
  tags: [...],
  metadata: {...},
  parallelism: 5
)
```

Features:
- Auto-resolves project and experiment IDs via API
- Parallel execution with configurable thread count
- Creates OpenTelemetry spans for eval/task/score
- Returns result with permalink

### Braintrust::Eval::Scorer

**lib/braintrust/eval/scorer.rb**

Scorer interface and helpers.

```ruby
# Using the helper
scorer = Braintrust::Eval.scorer("equals") do |input, expected, result, metadata|
  result == expected ? 1.0 : 0.0
end

# Or implement the interface
class MyScorer
  def name
    "my_scorer"
  end

  def call(input, expected, result, metadata)
    # return score (0.0 to 1.0)
  end
end
```

### Braintrust::API

**lib/braintrust/api.rb**

HTTP client for Braintrust API.

```ruby
api = Braintrust::API.new(state)
project = api.register_project(name)
experiment = api.register_experiment(name, project_id, options)
dataset = api.create_dataset(project_id, name, description)
```

## Design Decisions

### 1. State Management

**Decision**: Hybrid global + explicit state approach

**Rationale**:
- Simple cases don't need to pass state around
- Testing and multi-tenant scenarios can use explicit state
- Matches patterns from successful Python libraries
- Avoids global state issues in Go SDK

### 2. OpenTelemetry Integration

**Decision**: Users interact with OpenTelemetry directly for tracing

**Rationale**:
- Standard observability interface
- Works with existing OTEL instrumentation
- Braintrust adds span processor for metadata
- No custom tracing API to learn

### 3. OpenAI Integration via Faraday

**Decision**: Faraday middleware for instrumentation

**Rationale**:
- ruby-openai uses Faraday internally
- Middleware pattern is clean and non-invasive
- Can intercept requests/responses without patching
- Easy to add/remove

### 4. Thread-based Parallelism for Evals

**Decision**: Use Ruby threads for parallel execution

**Rationale**:
- Simple and built-in
- Sufficient for I/O-bound eval tasks
- No external dependencies
- Can add Ractor support later if needed

## Testing Strategy

### Test Helpers

**test/test_helper.rb**

Utilities for testing:
- Mock OTEL span exporter for capturing spans
- State setup/teardown helpers
- Custom assertions for span attributes
- Mock API responses

### Test Coverage Targets

- 80%+ overall coverage
- 100% for critical paths (state management, span processor)
- Integration tests with real OTEL setup
- Thread safety tests
- Both global and explicit state scenarios

## Dependencies

### Runtime
- `opentelemetry-sdk` (~> 1.5) - OpenTelemetry SDK
- `opentelemetry-exporter-otlp` (~> 0.29) - OTLP exporter
- `ruby-openai` (~> 7.0) - OpenAI client
- `faraday` (~> 2.0) - HTTP client (used by ruby-openai)

### Development
- `minitest` (~> 5.0) - Testing framework
- `standard` (~> 1.0) - Linting
- `simplecov` - Code coverage
- `rake` - Task automation

### Tools (via mise)
- Ruby 3.2, 3.3, 3.4
- watchexec - File watching for tests

## Key Differences from Go SDK

1. **State Management**: Hybrid global/explicit vs pure global
2. **API Style**: Ruby blocks/procs vs Go functions
3. **Middleware**: Faraday vs HTTP middleware
4. **Parallelism**: Threads vs goroutines
5. **Testing**: Minitest vs testify
6. **Linting**: Standard vs golangci-lint

## Future Enhancements

- Support for additional LLM providers (Anthropic, Google)
- Ractor-based parallelism for better performance
- Dataset management helpers
- Prompt management integration
- Additional built-in scorers
- Streaming response support for evals
